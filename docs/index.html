<!doctype html>
<html lang="en">
    <head>
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#f5ebdc" />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Set Game Detector</title>
        <style>
            body {
                font-family: sans-serif;
                margin: 0;
                padding: 0;
            }
            #container {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            video,
            canvas {
                max-width: 100%;
            }
            #status {
                margin-top: 1rem;
            }
            #perfBox {
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 14px;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <h2>Set Game Detection</h2>
            <video id="video" autoplay playsinline></video>
            <canvas
                id="captureCanvas"
                width="640"
                height="480"
                style="display: none"
            ></canvas>
            <canvas id="displayCanvas" width="640" height="480"></canvas>
            <div id="status">Loading models...</div>
            <div
                id="cardList"
                style="
                    white-space: pre;
                    margin-top: 1rem;
                    font-family: monospace;
                    font-size: 14px;
                "
            ></div>
            <div id="perfBox">seg: -, clf: -, set: -</div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
        <script>
            let tSeg = 0,
                tClf = 0,
                tSet = 0;
            let lastSets = [];
            let lastSetTime = 0;
            const SET_HOLD_MS = 2000;

            const COLORS = ["red", "green", "purple"];
            const SHAPES = ["diamond", "oval", "squiggle"];
            const FILLS = ["solid", "striped", "empty"];
            const COUNTS = ["one", "two", "three"];
            const YOLO_W = 640,
                YOLO_H = 480,
                IMG_SIZE = 224;
            const CONF_THRESH = 0.6,
                IOU_THRESH = 0.3,
                TARGET_FPS = 4;
            let lastFrameTime = 0;

            const video = document.getElementById("video");
            const captureCanvas = document.getElementById("captureCanvas");
            const displayCanvas = document.getElementById("displayCanvas");
            const statusEl = document.getElementById("status");
            const perfBox = document.getElementById("perfBox");
            const capCtx = captureCanvas.getContext("2d");
            const dispCtx = displayCanvas.getContext("2d");

            let yoloSession, clfSession;
            const cropCanvas = document.createElement("canvas");
            const cropCtx = cropCanvas.getContext("2d");

            function preprocessYOLO() {
                capCtx.drawImage(video, 0, 0, YOLO_W, YOLO_H);
                const img = capCtx.getImageData(0, 0, YOLO_W, YOLO_H);
                const d = img.data;
                const out = new Float32Array(3 * YOLO_W * YOLO_H);
                let r = 0,
                    g = YOLO_W * YOLO_H,
                    b = 2 * YOLO_W * YOLO_H;
                for (let i = 0; i < d.length; i += 4) {
                    out[r++] = d[i] / 255;
                    out[g++] = d[i + 1] / 255;
                    out[b++] = d[i + 2] / 255;
                }
                return new ort.Tensor("float32", out, [1, 3, YOLO_H, YOLO_W]);
            }

            const mean = [0.485, 0.456, 0.406];
            const std = [0.229, 0.224, 0.225];
            function preprocessClassifier(w, h) {
                const tmp = document.createElement("canvas");
                tmp.width = IMG_SIZE;
                tmp.height = IMG_SIZE;
                const tctx = tmp.getContext("2d");
                tctx.drawImage(
                    cropCanvas,
                    0,
                    0,
                    w,
                    h,
                    0,
                    0,
                    IMG_SIZE,
                    IMG_SIZE,
                );
                const img = tctx.getImageData(0, 0, IMG_SIZE, IMG_SIZE).data;
                const out = new Float32Array(3 * IMG_SIZE * IMG_SIZE);
                let r = 0,
                    g = IMG_SIZE * IMG_SIZE,
                    b = 2 * IMG_SIZE * IMG_SIZE;
                for (let i = 0; i < img.length; i += 4) {
                    out[r++] = (img[i] / 255 - mean[0]) / std[0];
                    out[g++] = (img[i + 1] / 255 - mean[1]) / std[1];
                    out[b++] = (img[i + 2] / 255 - mean[2]) / std[2];
                }
                return new ort.Tensor("float32", out, [
                    1,
                    3,
                    IMG_SIZE,
                    IMG_SIZE,
                ]);
            }

            function decodeYOLO(raw) {
                const arr = raw.data;
                const stride = 6300;
                const cx = arr.subarray(0, stride),
                    cy = arr.subarray(stride, 2 * stride),
                    w = arr.subarray(2 * stride, 3 * stride),
                    h = arr.subarray(3 * stride, 4 * stride),
                    conf = arr.subarray(4 * stride, 5 * stride);
                const out = [];
                for (let i = 0; i < stride; i++) {
                    if (conf[i] < CONF_THRESH) continue;
                    const x1 = cx[i] - w[i] / 2,
                        y1 = cy[i] - h[i] / 2,
                        x2 = cx[i] + w[i] / 2,
                        y2 = cy[i] + h[i] / 2;
                    if (x2 <= x1 || y2 <= y1) continue;
                    out.push([x1, y1, x2, y2, conf[i]]);
                }
                return out;
            }

            function iou(a, b) {
                const x1 = Math.max(a[0], b[0]),
                    y1 = Math.max(a[1], b[1]),
                    x2 = Math.min(a[2], b[2]),
                    y2 = Math.min(a[3], b[3]);
                const w = Math.max(0, x2 - x1),
                    h = Math.max(0, y2 - y1);
                const inter = w * h;
                if (!inter) return 0;
                const areaA = (a[2] - a[0]) * (a[3] - a[1]),
                    areaB = (b[2] - b[0]) * (b[3] - b[1]);
                return inter / (areaA + areaB - inter);
            }
            function nms(boxes) {
                boxes.sort((a, b) => b[4] - a[4]);
                const keep = [];
                while (boxes.length) {
                    const a = boxes.shift();
                    keep.push(a);
                    boxes = boxes.filter((b) => iou(a, b) < IOU_THRESH);
                }
                return keep;
            }
            function argmax(t) {
                let m = t[0],
                    idx = 0;
                for (let i = 1; i < t.length; i++)
                    if (t[i] > m) (m = t[i]), (idx = i);
                return idx;
            }

            function attrOK(x, y, z) {
                return (x === y && y === z) || (x !== y && x !== z && y !== z);
            }
            function isSet(a, b, c) {
                return (
                    attrOK(a.color, b.color, c.color) &&
                    attrOK(a.shape, b.shape, c.shape) &&
                    attrOK(a.fill, b.fill, c.fill) &&
                    attrOK(a.count, b.count, c.count)
                );
            }
            function findSets(cards) {
                const out = [];
                for (let i = 0; i < cards.length; i++)
                    for (let j = i + 1; j < cards.length; j++)
                        for (let k = j + 1; k < cards.length; k++)
                            if (
                                isSet(
                                    cards[i].attrs,
                                    cards[j].attrs,
                                    cards[k].attrs,
                                )
                            )
                                out.push([i, j, k]);
                return out;
            }

            async function loop(t) {
                if (t - lastFrameTime < 1000 / TARGET_FPS)
                    return requestAnimationFrame(loop);
                lastFrameTime = t;
                let t0 = performance.now();
                const yIn = preprocessYOLO();
                const yOut = await yoloSession.run({
                    [yoloSession.inputNames[0]]: yIn,
                });
                const dets = nms(decodeYOLO(yOut[yoloSession.outputNames[0]]));
                tSeg = performance.now() - t0;
                dispCtx.drawImage(video, 0, 0, YOLO_W, YOLO_H);
                let t1 = performance.now();
                const cards = [];
                for (const [x1, y1, x2, y2, conf] of dets) {
                    const w = (x2 - x1) | 0,
                        h = (y2 - y1) | 0;
                    if (w < 5 || h < 5) continue;
                    cropCanvas.width = w;
                    cropCanvas.height = h;
                    cropCtx.drawImage(displayCanvas, x1, y1, w, h, 0, 0, w, h);
                    const clfIn = preprocessClassifier(w, h);
                    const out = await clfSession.run({
                        [clfSession.inputNames[0]]: clfIn,
                    });
                    const attrs = {
                        color: COLORS[argmax(out.color.data)],
                        shape: SHAPES[argmax(out.shape.data)],
                        fill: FILLS[argmax(out.fill.data)],
                        count: COUNTS[argmax(out.count.data)],
                    };
                    cards.push({ box: [x1, y1, x2, y2], attrs });
                }
                tClf = performance.now() - t1;

                let t2 = performance.now();
                const found = findSets(cards);
                tSet = performance.now() - t2;

                let showSets = found;
                const now = performance.now();
                if (found.length > 0) {
                    lastSets = found;
                    lastSetTime = now;
                } else if (now - lastSetTime < SET_HOLD_MS) {
                    showSets = lastSets;
                } else {
                    showSets = [];
                }

                const colors = ["#00FF00", "#FFFF00", "#3399FF"];
                for (const c of cards) {
                    const [x1, y1, x2, y2] = c.box;
                    dispCtx.strokeStyle = "lime";
                    dispCtx.lineWidth = 2;
                    dispCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                }
                for (let s = 0; s < showSets.length; s++) {
                    const col = colors[s % colors.length];
                    dispCtx.strokeStyle = col;
                    dispCtx.lineWidth = 4;
                    for (const idx of showSets[s]) {
                        const [x1, y1, x2, y2] = cards[idx].box;
                        dispCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    }
                }

                perfBox.textContent = `seg: ${tSeg.toFixed(1)}ms, clf: ${tClf.toFixed(1)}ms, set: ${tSet.toFixed(1)}ms`;

                // Update card list
                const list = cards
                    .map((c, i) => {
                        const a = c.attrs;
                        return `Card ${i + 1}: ${a.count} ${a.color} ${a.shape} ${a.fill}`;
                    })
                    .join("");
                document.getElementById("cardList").textContent = list;
                requestAnimationFrame(loop);
            }

            async function init() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "environment",
                        width: YOLO_W,
                        height: YOLO_H,
                    },
                });
                video.srcObject = stream;
                yoloSession = await ort.InferenceSession.create(
                    "segmentationv2.onnx",
                    { executionProviders: ["webgpu"] },
                );
                clfSession = await ort.InferenceSession.create(
                    "classification.onnx",
                    { executionProviders: ["webgpu"] },
                );

                statusEl.textContent = "Models loaded.";

                requestAnimationFrame(loop);
            }
            init();
        </script>
        <script>
            if ("serviceWorker" in navigator) {
                navigator.serviceWorker
                    .register("service-worker.js")
                    .catch((err) =>
                        console.error("SW registration failed", err),
                    );
            }
        </script>
    </body>
</html>
