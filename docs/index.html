<!doctype html>
<html lang="en">
    <head>
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#f5ebdc" />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Set Game Detector</title>

        <style>
            body {
                font-family: sans-serif;
                margin: 0;
                padding: 0;
            }
            #container {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            video,
            canvas {
                max-width: 100%;
            }
            #status {
                margin-top: 1rem;
            }
            #perfBox {
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 14px;
                pointer-events: none;
                z-index: 5;
            }
            #nextBtn {
                margin-top: 1rem;
                padding: 8px 16px;
                font-size: 15px;
                display: none;
                position: relative;
                z-index: 10;
            }
            #mainCanvas {
                position: relative;
                z-index: 1;
            }
        </style>
    </head>

    <body>
        <div id="container">
            <h2>Set Game Detection</h2>

            <video id="video" autoplay playsinline></video>

            <!-- Single unified canvas -->
            <canvas id="mainCanvas" width="640" height="480"></canvas>

            <button id="nextBtn">Next</button>

            <div id="status">Loading models...</div>

            <div
                id="cardList"
                style="
                    white-space: pre;
                    margin-top: 1rem;
                    font-family: monospace;
                    font-size: 14px;
                "
            ></div>

            <div id="perfBox">seg: -, clf: -, set: -</div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
        <script>
            let tSeg = 0,
                tClf = 0,
                tSet = 0;

            let lastDetections = [];
            let lastFoundSet = null;
            let lastSets = [];
            let pausedForResult = false;
            let isProcessing = false;

            const COLORS = ["red", "green", "purple"];
            const SHAPES = ["diamond", "oval", "squiggle"];
            const FILLS = ["solid", "striped", "empty"];
            const COUNTS = ["one", "two", "three"];

            const YOLO_W = 640,
                YOLO_H = 480,
                IMG_SIZE = 224;
            const CONF_THRESH = 0.6,
                IOU_THRESH = 0.3;

            const video = document.getElementById("video");
            const mainCanvas = document.getElementById("mainCanvas");
            const ctx = mainCanvas.getContext("2d");

            const nextBtn = document.getElementById("nextBtn");
            const perfBox = document.getElementById("perfBox");

            let yoloSession, clfSession;

            const cropCanvas = document.createElement("canvas");
            const cropCtx = cropCanvas.getContext("2d");

            /* ---------------- YOLO PREPROCESS ---------------- */
            function preprocessYOLO() {
                ctx.drawImage(video, 0, 0, YOLO_W, YOLO_H);
                const img = ctx.getImageData(0, 0, YOLO_W, YOLO_H);
                const d = img.data;

                const out = new Float32Array(3 * YOLO_W * YOLO_H);
                let r = 0,
                    g = YOLO_W * YOLO_H,
                    b = 2 * YOLO_W * YOLO_H;

                for (let i = 0; i < d.length; i += 4) {
                    out[r++] = d[i] / 255;
                    out[g++] = d[i + 1] / 255;
                    out[b++] = d[i + 2] / 255;
                }
                return new ort.Tensor("float32", out, [1, 3, YOLO_H, YOLO_W]);
            }

            /* ---------------- CLASSIFIER PREPROCESS ---------------- */
            const mean = [0.485, 0.456, 0.406],
                std = [0.229, 0.224, 0.225];

            function preprocessClassifier(w, h) {
                const tmp = document.createElement("canvas");
                tmp.width = IMG_SIZE;
                tmp.height = IMG_SIZE;

                const tctx = tmp.getContext("2d");
                tctx.drawImage(
                    cropCanvas,
                    0,
                    0,
                    w,
                    h,
                    0,
                    0,
                    IMG_SIZE,
                    IMG_SIZE,
                );

                const img = tctx.getImageData(0, 0, IMG_SIZE, IMG_SIZE).data;

                const out = new Float32Array(3 * IMG_SIZE * IMG_SIZE);
                let r = 0,
                    g = IMG_SIZE * IMG_SIZE,
                    b = 2 * IMG_SIZE * IMG_SIZE;

                for (let i = 0; i < img.length; i += 4) {
                    out[r++] = (img[i] / 255 - mean[0]) / std[0];
                    out[g++] = (img[i + 1] / 255 - mean[1]) / std[1];
                    out[b++] = (img[i + 2] / 255 - mean[2]) / std[2];
                }
                return new ort.Tensor("float32", out, [
                    1,
                    3,
                    IMG_SIZE,
                    IMG_SIZE,
                ]);
            }

            /* ---------------- YOLO DECODE + NMS ---------------- */
            function decodeYOLO(raw) {
                const arr = raw.data;
                const stride = 6300;
                const cx = arr.subarray(0, stride);
                const cy = arr.subarray(stride, 2 * stride);
                const w = arr.subarray(2 * stride, 3 * stride);
                const h = arr.subarray(3 * stride, 4 * stride);
                const conf = arr.subarray(4 * stride, 5 * stride);

                const out = [];

                for (let i = 0; i < stride; i++) {
                    if (conf[i] < CONF_THRESH) continue;

                    const x1 = cx[i] - w[i] / 2;
                    const y1 = cy[i] - h[i] / 2;
                    const x2 = cx[i] + w[i] / 2;
                    const y2 = cy[i] + h[i] / 2;

                    if (x2 <= x1 || y2 <= y1) continue;

                    out.push([x1, y1, x2, y2, conf[i]]);
                }
                return out;
            }

            function iou(a, b) {
                const x1 = Math.max(a[0], b[0]),
                    y1 = Math.max(a[1], b[1]),
                    x2 = Math.min(a[2], b[2]),
                    y2 = Math.min(a[3], b[3]);

                const w = Math.max(0, x2 - x1),
                    h = Math.max(0, y2 - y1);
                const inter = w * h;
                if (!inter) return 0;

                const areaA = (a[2] - a[0]) * (a[3] - a[1]);
                const areaB = (b[2] - b[0]) * (b[3] - b[1]);
                return inter / (areaA + areaB - inter);
            }

            function nms(boxes) {
                boxes.sort((a, b) => b[4] - a[4]);
                const keep = [];
                while (boxes.length) {
                    const a = boxes.shift();
                    keep.push(a);
                    boxes = boxes.filter((b) => iou(a, b) < IOU_THRESH);
                }
                return keep;
            }

            function argmax(a) {
                let m = 0;
                for (let i = 1; i < a.length; i++) if (a[i] > a[m]) m = i;
                return m;
            }

            function attrOK(a, b, c) {
                return (a === b && b === c) || (a !== b && a !== c && b !== c);
            }

            function isSet(a, b, c) {
                return (
                    attrOK(a.color, b.color, c.color) &&
                    attrOK(a.shape, b.shape, c.shape) &&
                    attrOK(a.fill, b.fill, c.fill) &&
                    attrOK(a.count, b.count, c.count)
                );
            }

            function findSets(cards) {
                const out = [];
                for (let i = 0; i < cards.length; i++)
                    for (let j = i + 1; j < cards.length; j++)
                        for (let k = j + 1; k < cards.length; k++)
                            if (
                                isSet(
                                    cards[i].attrs,
                                    cards[j].attrs,
                                    cards[k].attrs,
                                )
                            )
                                out.push([i, j, k]);
                return out;
            }

            /* ---------------- MAIN LOOP ---------------- */
            async function loop() {
                requestAnimationFrame(loop);

                if (pausedForResult) return;

                // live camera
                ctx.drawImage(video, 0, 0, YOLO_W, YOLO_H);

                if (!isProcessing) processFrame();
            }

            /* ---------------- PROCESS FRAME ---------------- */
            async function processFrame() {
                isProcessing = true;

                /* --- YOLO --- */
                let t0 = performance.now();
                const yIn = preprocessYOLO();
                const yOut = await yoloSession.run({
                    [yoloSession.inputNames[0]]: yIn,
                });
                const dets = nms(decodeYOLO(yOut[yoloSession.outputNames[0]]));
                tSeg = performance.now() - t0;

                /* --- CLASSIFIER --- */
                let cards = [];
                let t1 = performance.now();

                for (const [x1, y1, x2, y2, conf] of dets) {
                    const w = x2 - x1,
                        h = y2 - y1;
                    if (w < 5 || h < 5) continue;

                    cropCanvas.width = w;
                    cropCanvas.height = h;

                    cropCtx.drawImage(mainCanvas, x1, y1, w, h, 0, 0, w, h);

                    const clfIn = preprocessClassifier(w, h);
                    const out = await clfSession.run({
                        [clfSession.inputNames[0]]: clfIn,
                    });

                    cards.push({
                        box: [x1, y1, x2, y2],
                        attrs: {
                            color: COLORS[argmax(out.color.data)],
                            shape: SHAPES[argmax(out.shape.data)],
                            fill: FILLS[argmax(out.fill.data)],
                            count: COUNTS[argmax(out.count.data)],
                        },
                    });
                }
                tClf = performance.now() - t1;

                /* --- SETS --- */
                let t2 = performance.now();
                const sets = findSets(cards);
                tSet = performance.now() - t2;

                lastDetections = cards;
                lastSets = sets;

                if (sets.length > 0) {
                    lastFoundSet = sets[0];
                    pausedForResult = true;
                    renderResultOverlay();
                    nextBtn.style.display = "block";
                }

                isProcessing = false;
            }

            /* ---------------- DRAW RESULT ---------------- */
            function renderResultOverlay() {
                // freeze last frame
                ctx.drawImage(video, 0, 0, YOLO_W, YOLO_H);

                // draw all detections
                ctx.strokeStyle = "lime";
                ctx.lineWidth = 2;
                for (const c of lastDetections) {
                    const [x1, y1, x2, y2] = c.box;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                }

                // highlight selected set
                ctx.strokeStyle = "yellow";
                ctx.lineWidth = 4;
                for (const idx of lastFoundSet) {
                    const [x1, y1, x2, y2] = lastDetections[idx].box;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                }

                perfBox.textContent =
                    `seg: ${tSeg.toFixed(1)}ms, ` +
                    `clf: ${tClf.toFixed(1)}ms, ` +
                    `set: ${tSet.toFixed(1)}ms`;

                const cardLines = lastDetections.map((c, i) => {
                    const a = c.attrs;
                    return `Card ${i + 1}: ${a.count} ${a.color} ${a.shape} ${a.fill}`;
                });

                const setLines = lastSets.map((s, idx) => {
                    return `Set ${idx + 1}: ${s.join(", ")}`;
                });

                document.getElementById("cardList").textContent = [
                    ...cardLines,
                    ...setLines,
                ].join("\n");
            }

            nextBtn.onclick = () => {
                pausedForResult = false;
                nextBtn.style.display = "none";
            };

            /* ---------------- INIT ---------------- */
            async function init() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "environment",
                        width: YOLO_W,
                        height: YOLO_H,
                    },
                });
                video.srcObject = stream;

                yoloSession = await ort.InferenceSession.create(
                    "segmentationv2.onnx",
                    { executionProviders: ["webgpu"] },
                );
                clfSession = await ort.InferenceSession.create(
                    "classification.onnx",
                    { executionProviders: ["webgpu"] },
                );

                document.getElementById("status").textContent =
                    "Models loaded.";
                requestAnimationFrame(loop);
            }

            init();
        </script>

        <script>
            if ("serviceWorker" in navigator) {
                navigator.serviceWorker
                    .register("service-worker.js")
                    .catch((err) =>
                        console.error("SW registration failed", err),
                    );
            }
        </script>
    </body>
</html>
