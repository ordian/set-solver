<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#f5ebdc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Set Game Detector</title>

        <style>
            body {
                font-family: sans-serif;
                margin: 0;
                padding: 0;
            }
            #container {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            video,
            canvas {
                max-width: 100%;
            }
            #status {
                margin-top: 1rem;
            }

            #perfBox {
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 14px;
                pointer-events: none;
                z-index: 5;
            }

            #nextBtn,
            #uploadBtn {
                margin-top: 1rem;
                padding: 8px 16px;
                font-size: 15px;
                position: relative;
                z-index: 10;
                display: none;
                cursor: pointer;
            }

            #uploadBtn {
                display: block;
            } /* always shown */

            #mainCanvas {
                position: relative;
                z-index: 1;
                display: none; /* hidden until a set is detected OR manual upload */
            }
        </style>
    </head>

    <body>
        <div id="container">
            <h2>Set Game Detection v1.8</h2>

            <video id="video" autoplay playsinline></video>

            <canvas id="mainCanvas" width="640" height="480"></canvas>

            <input type="file" id="uploadBtn" accept="image/*" />

            <button id="nextBtn">Next</button>

            <div id="status">Loading models...</div>

            <div
                id="cardList"
                style="
                    white-space: pre;
                    margin-top: 1rem;
                    font-family: monospace;
                    font-size: 14px;
                "
            ></div>

            <div id="perfBox">seg: -, clf: -, set: -</div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
        <script>
            "use strict";
            // =================================================
            // Global State
            // =================================================
            let tSeg = 0,
                tClf = 0,
                tSet = 0;
            let lastDetections = [];
            let lastFoundSet = null;
            let lastSets = [];
            let paused = false;
            let isProcessing = false;
            let capturedImage = null; // frozen frame as ImageData

            const COLORS = ["red", "green", "purple"];
            const SHAPES = ["diamond", "oval", "squiggle"];
            const FILLS = ["solid", "striped", "empty"];
            const COUNTS = ["one", "two", "three"];

            const YOLO_W = 640;
            const YOLO_H = 480;
            const IMG_SIZE = 128;
            const CONF_THRESH = 0.7;
            const IOU_THRESH = 0.5;

            const video = /** @type {HTMLVideoElement} */ (
                document.getElementById("video")
            );
            const canvas = /** @type {HTMLCanvasElement} */ (
                document.getElementById("mainCanvas")
            );
            const ctx = canvas.getContext("2d", { willReadFrequently: true });

            const nextBtn = /** @type {HTMLButtonElement} */ (
                document.getElementById("nextBtn")
            );
            const uploadBtn = /** @type {HTMLInputElement} */ (
                document.getElementById("uploadBtn")
            );
            const perfBox = document.getElementById("perfBox");
            const statusDiv = document.getElementById("status");

            /** @type {ort.InferenceSession | null} */
            let yoloSession = null;
            /** @type {ort.InferenceSession | null} */
            let clfSession = null;

            const cropCanvas = document.createElement("canvas");
            const cropCtx = cropCanvas.getContext("2d");

            // =================================================
            // Utilities
            // =================================================
            /**
             * @param {string|number} text
             * @param {number} x
             * @param {number} y
             */
            function drawCenteredText(text, x, y) {
                ctx.font = "30px sans-serif";
                ctx.fillStyle = "yellow";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(String(text), x, y);
            }

            // =================================================
            // Preprocessors
            // =================================================
            /**
             * @param {ImageData} img
             * @returns {ort.Tensor}
             */
            function preprocessYOLO_fromImageData(img) {
                const d = img.data;
                const out = new Float32Array(3 * YOLO_W * YOLO_H);

                let r = 0,
                    g = YOLO_W * YOLO_H,
                    b = 2 * YOLO_W * YOLO_H;
                for (let i = 0; i < d.length; i += 4) {
                    out[r++] = d[i] / 255;
                    out[g++] = d[i + 1] / 255;
                    out[b++] = d[i + 2] / 255;
                }
                return new ort.Tensor("float32", out, [1, 3, YOLO_H, YOLO_W]);
            }

            const mean = [0.485, 0.456, 0.406];
            const std = [0.229, 0.224, 0.225];

            /**
             * @param {number} w
             * @param {number} h
             * @returns {ort.Tensor}
             */
            function preprocessClassifier(w, h) {
                const tmp = document.createElement("canvas");
                tmp.width = IMG_SIZE;
                tmp.height = IMG_SIZE;
                const tctx = tmp.getContext("2d");
                tctx.drawImage(
                    cropCanvas,
                    0,
                    0,
                    w,
                    h,
                    0,
                    0,
                    IMG_SIZE,
                    IMG_SIZE,
                );

                const img = tctx.getImageData(0, 0, IMG_SIZE, IMG_SIZE).data;
                const out = new Float32Array(3 * IMG_SIZE * IMG_SIZE);

                let r = 0,
                    g = IMG_SIZE * IMG_SIZE,
                    b = 2 * IMG_SIZE * IMG_SIZE;
                for (let i = 0; i < img.length; i += 4) {
                    out[r++] = (img[i] / 255 - mean[0]) / std[0];
                    out[g++] = (img[i + 1] / 255 - mean[1]) / std[1];
                    out[b++] = (img[i + 2] / 255 - mean[2]) / std[2];
                }
                return new ort.Tensor("float32", out, [
                    1,
                    3,
                    IMG_SIZE,
                    IMG_SIZE,
                ]);
            }

            // =================================================
            // YOLO decode
            // =================================================
            /**
             * @param {ort.Tensor} raw
             * @returns {Array<[number, number, number, number, number]>}
             */
            function decodeYOLO(raw) {
                const arr = raw.data;
                const stride = 6300;
                const cx = arr.subarray(0, stride);
                const cy = arr.subarray(stride, 2 * stride);
                const w = arr.subarray(2 * stride, 3 * stride);
                const h = arr.subarray(3 * stride, 4 * stride);
                const conf = arr.subarray(4 * stride, 5 * stride);

                const out = [];
                for (let i = 0; i < stride; i++) {
                    if (conf[i] < CONF_THRESH) continue;
                    const x1 = cx[i] - w[i] / 2;
                    const y1 = cy[i] - h[i] / 2;
                    const x2 = cx[i] + w[i] / 2;
                    const y2 = cy[i] + h[i] / 2;
                    if (x2 <= x1 || y2 <= y1) continue;
                    out.push([x1, y1, x2, y2, conf[i]]);
                }
                return out;
            }

            /**
             * @param {number[]} a
             * @param {number[]} b
             * @returns {number}
             */
            function iou(a, b) {
                const x1 = Math.max(a[0], b[0]),
                    y1 = Math.max(a[1], b[1]),
                    x2 = Math.min(a[2], b[2]),
                    y2 = Math.min(a[3], b[3]),
                    w = Math.max(0, x2 - x1),
                    h = Math.max(0, y2 - y1),
                    inter = w * h;
                if (!inter) return 0;
                const areaA = (a[2] - a[0]) * (a[3] - a[1]);
                const areaB = (b[2] - b[0]) * (b[3] - b[1]);
                return inter / (areaA + areaB - inter);
            }

            /**
             * @param {Array<[number, number, number, number, number]>} boxes
             * @returns {Array<[number, number, number, number, number]>}
             */
            function nms(boxes) {
                boxes.sort((a, b) => b[4] - a[4]);
                const keep = [];
                while (boxes.length) {
                    const a = boxes.shift();
                    keep.push(a);
                    boxes = boxes.filter((b) => iou(a, b) < IOU_THRESH);
                }
                return keep;
            }

            /**
             * @param {Float32Array|number[]} a
             * @returns {number}
             */
            function argmax(a) {
                let m = 0;
                for (let i = 1; i < a.length; i++) if (a[i] > a[m]) m = i;
                return m;
            }

            // SET rules
            /**
             * @param {string|number} a
             * @param {string|number} b
             * @param {string|number} c
             * @returns {boolean}
             */
            function attrOK(a, b, c) {
                return (a === b && b === c) || (a !== b && a !== c && b !== c);
            }
            /**
             * @param {{color:string;shape:string;fill:string;count:string}} a
             * @param {{color:string;shape:string;fill:string;count:string}} b
             * @param {{color:string;shape:string;fill:string;count:string}} c
             * @returns {boolean}
             */
            function isSet(a, b, c) {
                return (
                    attrOK(a.color, b.color, c.color) &&
                    attrOK(a.shape, b.shape, c.shape) &&
                    attrOK(a.fill, b.fill, c.fill) &&
                    attrOK(a.count, b.count, c.count)
                );
            }
            /**
             * @param {{attrs:{color:string;shape:string;fill:string;count:string}}[]} cards
             * @returns {number[][]}
             */
            function findSets(cards) {
                const out = [];
                for (let i = 0; i < cards.length; i++)
                    for (let j = i + 1; j < cards.length; j++)
                        for (let k = j + 1; k < cards.length; k++)
                            if (
                                isSet(
                                    cards[i].attrs,
                                    cards[j].attrs,
                                    cards[k].attrs,
                                )
                            )
                                out.push([i, j, k]);
                return out;
            }

            // =================================================
            // Main Loop (only when NOT paused)
            // =================================================
            async function loop() {
                requestAnimationFrame(loop);
                if (paused) return;

                // show live video
                ctx.drawImage(video, 0, 0, YOLO_W, YOLO_H);

                if (!isProcessing) {
                    // capture the current frame as ImageData
                    capturedImage = ctx.getImageData(0, 0, YOLO_W, YOLO_H);
                    // fire and forget; do not await to keep UI responsive
                    void processFrame(capturedImage);
                }
            }

            // =================================================
            // Manual Upload
            // =================================================
            uploadBtn.onchange = async function (e) {
                const file = this.files && this.files[0];
                if (!file) {
                    return;
                }

                // Stop the loop BEFORE drawing, or video will overwrite the canvas
                paused = true;
                video.style.display = "none";
                canvas.style.display = "block";

                const img = new Image();
                img.onload = () => {
                    // hard-stop video immediately
                    isProcessing = false; // cancel any pending processing
                    capturedImage = null;
                    ctx.drawImage(img, 0, 0, YOLO_W, YOLO_H);

                    capturedImage = ctx.getImageData(0, 0, YOLO_W, YOLO_H);

                    processFrame(capturedImage);
                };

                img.src = URL.createObjectURL(file);
            };

            // =================================================
            // Process a single frame (stateless)
            // =================================================
            /**
             * @param {ImageData} imageData
             */
            async function processFrame(imageData) {
                isProcessing = true;

                // YOLO
                const t0 = performance.now();
                const yIn = preprocessYOLO_fromImageData(imageData);
                const yOut = await yoloSession.run({
                    [yoloSession.inputNames[0]]: yIn,
                });
                const dets = nms(decodeYOLO(yOut[yoloSession.outputNames[0]]));
                tSeg = performance.now() - t0;

                // Classification
                const cards = [];
                const t1 = performance.now();

                for (const [x1, y1, x2, y2, conf] of dets) {
                    const x1c = Math.max(0, Math.min(YOLO_W - 1, x1));
                    const y1c = Math.max(0, Math.min(YOLO_H - 1, y1));
                    const x2c = Math.max(0, Math.min(YOLO_W - 1, x2));
                    const y2c = Math.max(0, Math.min(YOLO_H - 1, y2));

                    const w = x2c - x1c;
                    const h = y2c - y1c;
                    if (w < 5 || h < 5) continue;

                    cropCanvas.width = w;
                    cropCanvas.height = h;
                    cropCtx.drawImage(canvas, x1c, y1c, w, h, 0, 0, w, h);
                    // cropCtx.putImageData(imageData, -x1, -y1);

                    const clfIn = preprocessClassifier(w, h);
                    const out = await clfSession.run({
                        [clfSession.inputNames[0]]: clfIn,
                    });

                    cards.push({
                        box: [x1, y1, x2, y2],
                        attrs: {
                            color: COLORS[argmax(out.color.data)],
                            shape: SHAPES[argmax(out.shape.data)],
                            fill: FILLS[argmax(out.fill.data)],
                            count: COUNTS[argmax(out.count.data)],
                        },
                    });
                }

                tClf = performance.now() - t1;

                // Sets
                const t2 = performance.now();
                const sets = findSets(cards);
                tSet = performance.now() - t2;

                lastDetections = cards;
                lastSets = sets;

                if (sets.length > 0) {
                    paused = true;
                    lastFoundSet = sets[0];
                    renderFrozenResults();
                    nextBtn.style.display = "block";
                }

                isProcessing = false;
            }

            // =================================================
            // Draw results using capturedImage
            // =================================================
            function renderFrozenResults() {
                if (!capturedImage) {
                    return;
                }
                video.style.display = "none";
                canvas.style.display = "block";

                ctx.putImageData(capturedImage, 0, 0);

                // draw all detections
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;

                lastDetections.forEach((c, i) => {
                    const [x1, y1, x2, y2] = c.box;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

                    // draw card index in center
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    drawCenteredText(i + 1, cx, cy);
                });

                // highlight set
                ctx.strokeStyle = "green";
                ctx.lineWidth = 5;
                lastFoundSet.forEach((idx) => {
                    const [x1, y1, x2, y2] = lastDetections[idx].box;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                });

                // Perf
                perfBox.textContent =
                    `seg: ${tSeg.toFixed(1)}ms, ` +
                    `clf: ${tClf.toFixed(1)}ms, ` +
                    `set: ${tSet.toFixed(1)}ms`;

                // captions
                const cardLines = lastDetections.map((c, i) => {
                    const a = c.attrs;
                    return `Card ${i + 1}: ${a.count} ${a.color} ${a.shape} ${a.fill}`;
                });
                const setLines = lastSets.map(
                    (s, i) => `Set ${i + 1}: ${s.map((x) => x + 1).join(", ")}`,
                );

                document.getElementById("cardList").textContent = [
                    ...cardLines,
                    ...setLines,
                ].join("\n");
            }

            // =================================================
            // Continue Button
            // =================================================
            nextBtn.onclick = () => {
                paused = false;
                nextBtn.style.display = "none";
                video.style.display = "block";
                canvas.style.display = "none";
            };

            function isMobile() {
                const ua = navigator.userAgent || navigator.vendor;
                return /Android|webOS|iPhone|iPad/i.test(ua);
            }

            async function init() {
                try {
                    if (!("mediaDevices" in navigator)) {
                        throw new Error("Camera API not available");
                    }

                    // 1. Determine Backend
                    // Mobile -> WebGPU (Fast, working for you)
                    // Desktop -> WASM (CPU, slower but stable, fixes the freeze)
                    const useWebGPU = isMobile();
                    const provider = useWebGPU ? "webgpu" : "wasm";

                    console.log(`Device: ${useWebGPU ? "Mobile" : "Desktop"}`);
                    console.log(
                        `Switching backend to: ${provider.toUpperCase()}`,
                    );

                    statusDiv.textContent = `Loading models (${provider.toUpperCase()})...`;

                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: "environment" },
                            width: { ideal: YOLO_W },
                            height: { ideal: YOLO_H },
                        },
                    });
                    video.srcObject = stream;

                    const sessionOptions = {
                        executionProviders: [provider],
                        graphOptimizationLevel: "all",
                    };

                    // Load Models
                    yoloSession = await ort.InferenceSession.create(
                        "segmentationv3.onnx",
                        sessionOptions,
                    );
                    clfSession = await ort.InferenceSession.create(
                        "classificationv3.onnx",
                        sessionOptions,
                    );

                    statusDiv.textContent = `Ready (${provider}).`;
                    requestAnimationFrame(loop);
                } catch (e) {
                    console.error(e);
                    statusDiv.textContent = "Init Error: " + (e.message || e);
                }
            }

            init();
        </script>

        <script>
            "use strict";

            if ("serviceWorker" in navigator) {
                navigator.serviceWorker
                    .register("service-worker.js")
                    .catch((e) => console.error("SW registration failed", e));
            }
        </script>
    </body>
</html>
