<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#f5ebdc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Set Game Detector</title>

        <style>
            body {
                font-family: sans-serif;
                margin: 0;
                padding: 0;
            }
            #container {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            video,
            canvas {
                max-width: 100%;
            }
            #status {
                margin-top: 1rem;
            }

            #perfBox {
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 14px;
                pointer-events: none;
                z-index: 5;
            }

            #nextBtn,
            #uploadBtn {
                margin-top: 1rem;
                padding: 8px 16px;
                font-size: 15px;
                position: relative;
                z-index: 10;
                display: none;
                cursor: pointer;
            }

            #uploadBtn {
                display: block;
            } /* always shown */

            #mainCanvas {
                position: relative;
                z-index: 1;
                display: none; /* hidden until a set is detected OR manual upload */
            }
        </style>
    </head>

    <body>
        <div id="container">
            <h2>Set Game Detection v1.6</h2>

            <video id="video" autoplay playsinline></video>

            <canvas id="mainCanvas" width="640" height="480"></canvas>

            <input type="file" id="uploadBtn" accept="image/*" />

            <button id="nextBtn">Next</button>

            <div id="status">Loading models...</div>

            <div
                id="cardList"
                style="
                    white-space: pre;
                    margin-top: 1rem;
                    font-family: monospace;
                    font-size: 14px;
                "
            ></div>

            <div id="perfBox">seg: -, clf: -, set: -</div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
        <script>
            "use strict";
            // =================================================
            // Global State
            // =================================================
            let tSeg = 0,
                tClf = 0,
                tSet = 0;
            let lastDetections = [];
            let lastFoundSet = null;
            let lastSets = [];
            let paused = false;
            let isProcessing = false;
            let capturedImage = null; // frozen frame as ImageData

            const COLORS = ["red", "green", "purple"];
            const SHAPES = ["diamond", "oval", "squiggle"];
            const FILLS = ["solid", "striped", "empty"];
            const COUNTS = ["one", "two", "three"];

            const YOLO_W = 640;
            const YOLO_H = 480;
            const IMG_SIZE = 128; // Classifier input size
            const CONF_THRESH = 0.7;
            const IOU_THRESH = 0.5;

            const MEAN = [0.485, 0.456, 0.406];
            const STD = [0.229, 0.224, 0.225];

            const video = document.getElementById("video");
            const canvas = document.getElementById("mainCanvas");
            const ctx = canvas.getContext("2d", { willReadFrequently: true });

            const nextBtn = document.getElementById("nextBtn");
            const uploadBtn = document.getElementById("uploadBtn");
            const perfBox = document.getElementById("perfBox");

            /** @type {ort.InferenceSession | null} */
            let yoloSession = null;
            /** @type {ort.InferenceSession | null} */
            let clfSession = null;

            // =================================================
            // Utilities
            // =================================================
            function drawCenteredText(text, x, y) {
                ctx.font = "30px sans-serif";
                ctx.fillStyle = "yellow";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(String(text), x, y);
            }

            function argmaxOffset(data, offset, length) {
                let maxIdx = 0;
                let maxVal = data[offset];
                for (let i = 1; i < length; i++) {
                    if (data[offset + i] > maxVal) {
                        maxVal = data[offset + i];
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }

            // =================================================
            // Preprocessors (Stateless & Safe)
            // =================================================
            function preprocessYOLO_fromImageData(img) {
                // Allocate new buffer per frame to prevent race conditions
                const out = new Float32Array(3 * YOLO_W * YOLO_H);
                const d = img.data;
                let r = 0,
                    g = YOLO_W * YOLO_H,
                    b = 2 * YOLO_W * YOLO_H;
                for (let i = 0; i < d.length; i += 4) {
                    out[r++] = d[i] / 255.0;
                    out[g++] = d[i + 1] / 255.0;
                    out[b++] = d[i + 2] / 255.0;
                }
                return new ort.Tensor("float32", out, [1, 3, YOLO_H, YOLO_W]);
            }

            /**
             * Batched Preprocessing
             * Creates a tensor [N, 3, 128, 128]
             */
            function preprocessBatch(boxes, sourceBitmap) {
                const N = boxes.length;
                if (N === 0) return null;

                // Create a local canvas for this batch to avoid global state conflicts
                const batchCanvas = document.createElement("canvas");
                batchCanvas.width = IMG_SIZE;
                batchCanvas.height = IMG_SIZE;
                const batchCtx = batchCanvas.getContext("2d", {
                    willReadFrequently: true,
                });

                const stride = IMG_SIZE * IMG_SIZE;
                const data = new Float32Array(N * 3 * stride);

                for (let i = 0; i < N; i++) {
                    const [x1, y1, x2, y2] = boxes[i];
                    const w = x2 - x1;
                    const h = y2 - y1;

                    // Draw crop from the FROZEN bitmap
                    batchCtx.drawImage(
                        sourceBitmap,
                        x1,
                        y1,
                        w,
                        h,
                        0,
                        0,
                        IMG_SIZE,
                        IMG_SIZE,
                    );

                    const imgData = batchCtx.getImageData(
                        0,
                        0,
                        IMG_SIZE,
                        IMG_SIZE,
                    ).data;

                    // Layout: [Batch, Channel, Row, Col]
                    let rStart = i * 3 * stride;
                    let gStart = rStart + stride;
                    let bStart = gStart + stride;

                    for (let k = 0; k < imgData.length; k += 4) {
                        data[rStart++] =
                            (imgData[k] / 255.0 - MEAN[0]) / STD[0];
                        data[gStart++] =
                            (imgData[k + 1] / 255.0 - MEAN[1]) / STD[1];
                        data[bStart++] =
                            (imgData[k + 2] / 255.0 - MEAN[2]) / STD[2];
                    }
                }
                return new ort.Tensor("float32", data, [
                    N,
                    3,
                    IMG_SIZE,
                    IMG_SIZE,
                ]);
            }

            // =================================================
            // YOLO Logic
            // =================================================
            function decodeYOLO(raw) {
                const arr = raw.data;
                const stride = 6300;
                const cx = arr.subarray(0, stride);
                const cy = arr.subarray(stride, 2 * stride);
                const w = arr.subarray(2 * stride, 3 * stride);
                const h = arr.subarray(3 * stride, 4 * stride);
                const conf = arr.subarray(4 * stride, 5 * stride);

                const out = [];
                for (let i = 0; i < stride; i++) {
                    if (conf[i] < CONF_THRESH) continue;
                    const x1 = cx[i] - w[i] / 2;
                    const y1 = cy[i] - h[i] / 2;
                    const x2 = cx[i] + w[i] / 2;
                    const y2 = cy[i] + h[i] / 2;
                    if (x2 <= x1 || y2 <= y1) continue;
                    out.push([x1, y1, x2, y2, conf[i]]);
                }
                return out;
            }

            function iou(a, b) {
                const x1 = Math.max(a[0], b[0]),
                    y1 = Math.max(a[1], b[1]);
                const x2 = Math.min(a[2], b[2]),
                    y2 = Math.min(a[3], b[3]);
                const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                if (!inter) return 0;
                const areaA = (a[2] - a[0]) * (a[3] - a[1]);
                const areaB = (b[2] - b[0]) * (b[3] - b[1]);
                return inter / (areaA + areaB - inter);
            }

            function nms(boxes) {
                boxes.sort((a, b) => b[4] - a[4]);
                const keep = [];
                while (boxes.length) {
                    const a = boxes.shift();
                    keep.push(a);
                    boxes = boxes.filter((b) => iou(a, b) < IOU_THRESH);
                }
                return keep;
            }

            // =================================================
            // Set Game Logic
            // =================================================
            function attrOK(a, b, c) {
                return (a === b && b === c) || (a !== b && a !== c && b !== c);
            }
            function isSet(a, b, c) {
                return (
                    attrOK(a.color, b.color, c.color) &&
                    attrOK(a.shape, b.shape, c.shape) &&
                    attrOK(a.fill, b.fill, c.fill) &&
                    attrOK(a.count, b.count, c.count)
                );
            }
            function findSets(cards) {
                const out = [];
                const n = cards.length;
                for (let i = 0; i < n; i++)
                    for (let j = i + 1; j < n; j++)
                        for (let k = j + 1; k < n; k++)
                            if (
                                isSet(
                                    cards[i].attrs,
                                    cards[j].attrs,
                                    cards[k].attrs,
                                )
                            )
                                out.push([i, j, k]);
                return out;
            }

            // =================================================
            // Main Loop
            // =================================================
            async function loop() {
                requestAnimationFrame(loop);
                if (paused) return;

                ctx.drawImage(video, 0, 0, YOLO_W, YOLO_H);

                if (!isProcessing) {
                    isProcessing = true;
                    // Capture raw data
                    capturedImage = ctx.getImageData(0, 0, YOLO_W, YOLO_H);

                    // Create bitmap for cropping (Async)
                    createImageBitmap(capturedImage)
                        .then((bitmap) => {
                            processFrame(capturedImage, bitmap);
                        })
                        .catch((e) => {
                            console.error("Bitmap error:", e);
                            isProcessing = false;
                        });
                }
            }

            uploadBtn.onchange = function () {
                const file = this.files && this.files[0];
                if (!file) return;

                // Prevent interrupting if busy to avoid crash
                if (isProcessing) {
                    console.warn("Processing in progress, wait a moment...");
                    // Optionally could handle a retry here, but safe exit is better
                }

                paused = true; // Stop the camera loop
                video.style.display = "none";
                canvas.style.display = "block";

                const img = new Image();
                img.onload = () => {
                    // Draw image to canvas
                    ctx.drawImage(img, 0, 0, YOLO_W, YOLO_H);

                    // Capture data
                    capturedImage = ctx.getImageData(0, 0, YOLO_W, YOLO_H);

                    // Lock and Process
                    isProcessing = true;
                    createImageBitmap(capturedImage)
                        .then((bitmap) => {
                            processFrame(capturedImage, bitmap);
                        })
                        .catch((e) => {
                            console.error(e);
                            isProcessing = false;
                        });
                };
                img.src = URL.createObjectURL(file);
            };

            // =================================================
            // Process Frame
            // =================================================
            async function processFrame(imageData, sourceBitmap) {
                try {
                    // 1. YOLO Inference
                    const t0 = performance.now();
                    const yIn = preprocessYOLO_fromImageData(imageData);

                    const yOut = await yoloSession.run({
                        [yoloSession.inputNames[0]]: yIn,
                    });

                    const dets = nms(
                        decodeYOLO(yOut[yoloSession.outputNames[0]]),
                    );
                    tSeg = performance.now() - t0;

                    // Filter boxes
                    const validDets = [];
                    for (const box of dets) {
                        const [x1, y1, x2, y2] = box;
                        const x1c = Math.max(0, Math.min(YOLO_W - 1, x1));
                        const y1c = Math.max(0, Math.min(YOLO_H - 1, y1));
                        const x2c = Math.max(0, Math.min(YOLO_W - 1, x2));
                        const y2c = Math.max(0, Math.min(YOLO_H - 1, y2));
                        // Ensure crop is at least 10x10
                        if (x2c - x1c > 10 && y2c - y1c > 10) {
                            validDets.push([x1c, y1c, x2c, y2c]);
                        }
                    }

                    const cards = [];
                    let t1 = performance.now();

                    if (validDets.length > 0) {
                        // 2. Batched Classification
                        // Pass the frozen sourceBitmap to ensure pixel consistency
                        const batchTensor = preprocessBatch(
                            validDets,
                            sourceBitmap,
                        );

                        const clfResults = await clfSession.run({
                            [clfSession.inputNames[0]]: batchTensor,
                        });

                        const N = validDets.length;
                        const colorData = clfResults.color.data;
                        const shapeData = clfResults.shape.data;
                        const fillData = clfResults.fill.data;
                        const countData = clfResults.count.data;

                        for (let i = 0; i < N; i++) {
                            cards.push({
                                box: validDets[i],
                                attrs: {
                                    color: COLORS[
                                        argmaxOffset(colorData, i * 3, 3)
                                    ],
                                    shape: SHAPES[
                                        argmaxOffset(shapeData, i * 3, 3)
                                    ],
                                    fill: FILLS[
                                        argmaxOffset(fillData, i * 3, 3)
                                    ],
                                    count: COUNTS[
                                        argmaxOffset(countData, i * 3, 3)
                                    ],
                                },
                            });
                        }
                    }
                    tClf = performance.now() - t1;

                    // 3. Set Logic
                    const t2 = performance.now();
                    const sets = findSets(cards);
                    tSet = performance.now() - t2;

                    lastDetections = cards;
                    lastSets = sets;

                    if (sets.length > 0) {
                        paused = true;
                        lastFoundSet = sets[0];
                        renderFrozenResults();
                        nextBtn.style.display = "block";
                    }
                } catch (err) {
                    console.error("Processing Error Details:", err);
                    // Display full error on screen
                    perfBox.textContent = "Error: " + (err.message || err);
                } finally {
                    if (sourceBitmap) sourceBitmap.close();
                    isProcessing = false;
                }
            }

            function renderFrozenResults() {
                if (!capturedImage) return;
                video.style.display = "none";
                canvas.style.display = "block";
                ctx.putImageData(capturedImage, 0, 0);

                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                lastDetections.forEach((c, i) => {
                    const [x1, y1, x2, y2] = c.box;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    drawCenteredText(i + 1, cx, cy);
                });

                if (lastFoundSet) {
                    ctx.strokeStyle = "#00ff00";
                    ctx.lineWidth = 6;
                    lastFoundSet.forEach((idx) => {
                        const [x1, y1, x2, y2] = lastDetections[idx].box;
                        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    });
                }

                perfBox.textContent =
                    `seg: ${tSeg.toFixed(1)}ms, ` +
                    `clf: ${tClf.toFixed(1)}ms (n=${lastDetections.length}), ` +
                    `set: ${tSet.toFixed(1)}ms`;

                const cardLines = lastDetections.map((c, i) => {
                    const a = c.attrs;
                    return `Card ${i + 1}: ${a.count} ${a.color} ${a.shape} ${a.fill}`;
                });
                const setLines = lastSets.map(
                    (s, i) => `Set ${i + 1}: ${s.map((x) => x + 1).join(", ")}`,
                );
                document.getElementById("cardList").textContent = [
                    ...cardLines,
                    ...setLines,
                ].join("\n");
            }

            nextBtn.onclick = () => {
                paused = false;
                nextBtn.style.display = "none";
                video.style.display = "block";
                canvas.style.display = "none";
            };

            async function init() {
                try {
                    if (!("mediaDevices" in navigator))
                        throw new Error("No Camera API");

                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { ideal: "environment" },
                            width: { ideal: YOLO_W },
                            height: { ideal: YOLO_H },
                        },
                    });
                    video.srcObject = stream;

                    // Load Models with Optimization Enabled
                    yoloSession = await ort.InferenceSession.create(
                        "segmentationv3.onnx",
                        {
                            executionProviders: ["webgpu"],
                            graphOptimizationLevel: "all",
                        },
                    );
                    clfSession = await ort.InferenceSession.create(
                        "classificationv3.onnx",
                        {
                            executionProviders: ["webgpu"],
                            graphOptimizationLevel: "all",
                        },
                    );

                    document.getElementById("status").textContent =
                        "Models Ready (Batching + WebGPU).";
                    requestAnimationFrame(loop);
                } catch (e) {
                    console.error(e);
                    document.getElementById("status").textContent =
                        "Init Error: " + e.message;
                }
            }

            init();
        </script>

        <script>
            "use strict";

            if ("serviceWorker" in navigator) {
                navigator.serviceWorker
                    .register("service-worker.js")
                    .catch((e) => console.error("SW registration failed", e));
            }
        </script>
    </body>
</html>
